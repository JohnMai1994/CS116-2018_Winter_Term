ASSIGNMENT 08
Student's Quest ID: j4mai

**** Testing Results **********************************************************

56/56   Total Mark

 ** Question 1: 16/16
 ** Question 2: 6/6
 ** Question 3: 28/28
 ** Question 4: 6/6

(Question 1, Test t01, 1 marks): ^apart a: simple no wraparound^a: Passed;
    passed.
(Question 1, Test t02, 1 marks): ^apart a: mixed case and non-alpha^a: Passed;
    passed.
(Question 1, Test t03, 1 marks): ^apart a: all non-alphabetic^a: Passed; passe\
d.
(Question 1, Test t04, 1 marks): ^apart a: full cycle, equal frequency^a:
    Passed; passed.
(Question 1, Test t05, 1 marks): ^apart a: single letter^a: Passed; passed.
(Question 1, Test t06, 1 marks): ^apart a: more non-alpha characters^a: Passed\
;
    passed.
(Question 1, Test t07, 1 marks): ^apart a: empty string^a: Passed; passed.
(Question 1, Test t08, 1 marks): ^apart a: > 26 wrap^a: Passed; passed.
(Question 1, Test t09, 1 marks): ^apart b: simple no wraparound^a: Passed;
    passed.
(Question 1, Test t10, 1 marks): ^apart b: mixed case and non-alpha^a: Passed;
    passed.
(Question 1, Test t11, 1 marks): ^apart b: all non-alphabetic^a: Passed; passe\
d.
(Question 1, Test t12, 1 marks): ^apart b: full cycle, equal frequency^a:
    Passed; passed.
(Question 1, Test t13, 1 marks): ^apart b: single letter^a: Passed; passed.
(Question 1, Test t14, 1 marks): ^apart b: more non-alpha characters^a: Passed\
;
    passed.
(Question 1, Test t15, 1 marks): ^apart b: empty string^a: Passed; passed.
(Question 1, Test t16, 1 marks): ^apart b: > 26 wrap ^a: Passed; passed.
(Question 2, Test t01, 1 marks): ^anumbers added, no win (some mutation)^a:
    Passed; passed.
(Question 2, Test t02, 1 marks): ^anumbers not on card (no change mutation)^a:
    Passed; passed.
(Question 2, Test t03, 1 marks): ^ano numbers added (no change mutation)^a:
    Passed; passed.
(Question 2, Test t04, 1 marks): ^acolumn win (column win mutation)^a: Passed;
    passed.
(Question 2, Test t05, 1 marks): ^arow win (row win mutation)^a: Passed; passe\
d.
(Question 2, Test t06, 1 marks): ^arow and column win (row/col win mutation)^a\
:
    Passed; passed.
(Question 3, Test t01, 1 marks): ^aadd- all positives^a: Passed; passed.
(Question 3, Test t02, 1 marks): ^aadd- zero x^a: Passed; passed.
(Question 3, Test t03, 1 marks): ^aadd- zero y^a: Passed; passed.
(Question 3, Test t04, 1 marks): ^aadd- zero sum^a: Passed; passed.
(Question 3, Test t05, 1 marks): ^adp- all positives^a: Passed; passed.
(Question 3, Test t06, 1 marks): ^adp- orthogonal^a: Passed; passed.
(Question 3, Test t07, 1 marks): ^adp- negatives to positive^a: Passed; passed\
.
(Question 3, Test t08, 1 marks): ^alength- all positives^a: Passed; passed.
(Question 3, Test t09, 1 marks): ^alength- zero x^a: Passed; passed.
(Question 3, Test t10, 1 marks): ^alength- zero y^a: Passed; passed.
(Question 3, Test t11, 1 marks): ^alength- all negatives^a: Passed; passed.
(Question 3, Test t12, 1 marks): ^ascale- positive scale (mutation u)^a: Passe\
d;
    passed.
(Question 3, Test t13, 1 marks): ^ascale- negative scale (mutation w)^a: Passe\
d;
    passed.
(Question 3, Test t14, 1 marks): ^ascale- zero scale (mutation v)^a: Passed;
    passed.
(Question 3, Test t15, 1 marks): ^a+: all positives^a: Passed; passed.
(Question 3, Test t16, 1 marks): ^a+: zero x^a: Passed; passed.
(Question 3, Test t17, 1 marks): ^a+: zero y^a: Passed; passed.
(Question 3, Test t18, 1 marks): ^a+: zero sum^a: Passed; passed.
(Question 3, Test t19, 1 marks): ^a*: all positives^a: Passed; passed.
(Question 3, Test t20, 1 marks): ^a*: orthogonal^a: Passed; passed.
(Question 3, Test t21, 1 marks): ^a*: negatives to positive^a: Passed; passed.
(Question 3, Test t22, 1 marks): ^alength- all positives^a: Passed; passed.
(Question 3, Test t23, 1 marks): ^alength- zero x^a: Passed; passed.
(Question 3, Test t24, 1 marks): ^alength- zero y^a: Passed; passed.
(Question 3, Test t25, 1 marks): ^alength- all negatives^a: Passed; passed.
(Question 3, Test t26, 1 marks): ^ascale- positive scale (mutation u)^a: Passe\
d;
    passed.
(Question 3, Test t27, 1 marks): ^ascale- negative scale (mutation w)^a: Passe\
d;
    passed.
(Question 3, Test t28, 1 marks): ^ascale- zero scale (mutation v)^a: Passed;
    passed.
(Question 4, Test t01, 1 marks): ^ano vectors in list^a: Passed; passed.
(Question 4, Test t02, 1 marks): ^aone per list^a: Passed; passed.
(Question 4, Test t03, 1 marks): ^asome empty, some not^a: Passed; passed.
(Question 4, Test t04, 1 marks): ^aall same category^a: Passed; passed.
(Question 4, Test t05, 1 marks): ^amultiple repeated^a: Passed; passed.
(Question 4, Test t06, 1 marks): ^alarge set^a: Passed; passed.
112 control characters removed.


**** testing_result.txt *****************************************************************
Total number of tests missing: 3

shift_encode: All 5 required cases were tested.

shift_decode: All 5 required cases were tested.

play_bingo: 2 of the 7 required cases were missing:
 - empty list
 - column and row both win (yielding a column win)

add_vectors: All 2 required cases were tested.

dot_product: All 2 required cases were tested.

length: All 2 required cases were tested.

scale: All 2 required cases were tested.

__add__: All 2 required cases were tested.

__mul__: All 2 required cases were tested.

vector.length: 0 of the 2 required cases were missing:
 - pos and neg

vector.scale: All 2 required cases were tested.

classify_angles: 1 of the 5 required cases were missing:
 - empty list



**** a08q1.py *****************************************************************
##===============================================
##   Jiadong Mai (20557203)
##   CS 116 Winter 2018
##   Assignment 08, Question 1
##===============================================

import check
#q1a
# shift_encode(s) converts a string, s, to another by shifting each alphabetic 
#    character by a fixed amount, which determined by the most frequently 
#    alphabetic in s

# shift_encode: Str -> Str

# Examples:
# shift_encode('HEY! Where you at?') => "KHB! Zkhuh brx dw?"
# shift_encode("Q"*(26*2 + 3) + "w") => "T"*(26*2 + 3) + "z"
# shift_encode("a2b") => "b2c"

def shift_encode(s):
    character = {}
    for char in s:
        char = char.lower()
        if char.isalpha():
            if char in character:
                character[char] += 1
            else:
                character[char] = 1
            
    max_times = 0
    for curr_chars in character:
        if character[curr_chars] > max_times:
            max_times = character[curr_chars]
    
    s_character = 'abcdefghijklmnopqrstuvwxyz'
    l_character = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    
    def swap(char, num):
        if char.isupper():
            pos = (l_character.find(char) + num) % 26
            return l_character[pos]
        elif char.islower():
            pos = (s_character.find(char) + num) % 26
            return s_character[pos]
        else:
            return char
    
    return ''.join(list(map(lambda x: swap(x, max_times), s)))

# Test:
# String == '' or other None alpha
check.expect('T1(a)', shift_encode(''), '')
check.expect('T2(a)', shift_encode('132412'), '132412')
check.expect('T3(a)', shift_encode('?":#!'), '?":#!')
check.expect('T4(a)', shift_encode('13?"'), '13?"')
# String only alpha, contain Capital
check.expect('T5(a)', shift_encode('I love Computer Science'), 'M pszi Gsqtyxiv Wgmirgi')
check.expect('T6(a)', shift_encode('Z'* 23), 'W' * 23)
check.expect('T7(a)', shift_encode('AABBCCa'), 'DDEEFFd')
check.expect('T8(a)', shift_encode('abcdefghijk'), 'bcdefghijkl')
check.expect('T9(a)', shift_encode('ABCDEFGHIJKl'), 'BCDEFGHIJKLm')
# String mix alpha and other symbol
check.expect('T10(a)', shift_encode('      a'), '      b')
check.expect('T11(a)', shift_encode('#####aac'), '#####cce')
check.expect('T12(a)', shift_encode('&*1223AVbbUiF'), '&*1223CXddWkH')



#q1b
# shift_dncode(s) converts a string, s, to another by shifting each alphabetic 
#    character by a fixed amount, which determined by the most frequently 
#    alphabetic in s, inverse to the encode

# shift_dncode: Str -> Str

# shift_decode("KHB! Zkhuh brx dw?") => "HEY! Where you at?"
# shift_decode("Q"*26) => "Q"*26
# shift_decode("b2c") => "a2b"

def shift_decode(s):
    character = {}
    for char in s:
        char = char.lower()
        if char.isalpha():
            if char in character:
                character[char] += 1
            else:
                character[char] = 1
            
    max_times = 0
    for curr_chars in character:
        if character[curr_chars] > max_times:
            max_times = character[curr_chars]
    
    s_character = 'abcdefghijklmnopqrstuvwxyz'
    l_character = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
            
    def swap(char, num):
        if char.isupper():
            pos = (l_character.find(char) - num) % 26
            return l_character[pos]
        elif char.islower():
            pos = (s_character.find(char) - num) % 26
            return s_character[pos]
        else:
            return char
            
    return ''.join(list(map(lambda x: swap(x, max_times), s)))

# Test
# String == '' or other None alpha
check.expect('T1(b)', shift_decode(''), '')
check.expect('T2(b)', shift_decode('132412'), '132412')
check.expect('T3(b)', shift_decode('?":#!'), '?":#!')
check.expect('T4(b)', shift_decode('13?"'), '13?"')
# String only alpha, contain Capital
check.expect('T5(b)', shift_decode('I love Computer Science'), 'E hkra Ykilqpan Oyeajya')
check.expect('T6(b)', shift_decode('Z'* 23), 'C' * 23)
check.expect('T7(b)', shift_decode('AABBCCa'), 'XXYYZZx')
check.expect('T8(b)', shift_decode('abcdefghijk'), 'zabcdefghij')
check.expect('T9(b)', shift_decode('ABCDEFGHIJKl'), 'ZABCDEFGHIJk')
# String mix alpha and other symbol
check.expect('T10(b)', shift_decode('      a'), '      z')
check.expect('T11(b)', shift_decode('#####aac'), '#####yya')
check.expect('T12(b)', shift_decode('&*1223AVbbUiF'), '&*1223YTzzSgD')


**** a08q2.py *****************************************************************
##===============================================
##   Jiadong Mai (20557203)
##   CS 116 Winter 2018
##   Assignment 08, Question 2
##===============================================
#q2
import check
# ## a Bingocard is a (dictof Str (listof (anyof Nat 'XX'))) and 		
# ## represents a standard bingo card in 75 ball bingo
# ## requires: 
# ##	- it has exactly 5 key value pairs
# ##	- the keys are the capital letters 'B' 'I' 'N' 'G' 'O'
# ## 	- each list is length 5 and is made up of the string 'XX' or 
# ##	  numbers 1 through 75 according to the breakdown below
# ##	- key 'B' only has numbers between 1 and 15 inclusive 
# ##	- key 'I' only has numbers between 16 and 30 inclusive
# ##	- key 'N' only has numbers between 31 and 45 inclusive
# ##	- key 'G' only has numbers between 46 and 60 inclusive
# ##	- key 'O' only has numbers between 61 and 75 inclusive
# ##	- the associated list at key 'N' will always have its element at 
# ##	  index 2 equal to 'XX' (representing the free space)
# ##	- the numbers in each list must be unique

# display_bingo_card(crd) prints a nicely formatted version of crd
# Effects: 6 lines are printed
# display_bingo_card: Bingocard -> None

def display_bingo_card(crd):
    
    header = "  B  I  N  G  O  "
    
    print(header)
    
    for i in range(5):
        line = " {0:2} {1:2} {2:2} {3:2} {4:2}  ".format(crd['B'][i],
                                                         crd['I'][i],
                                                         crd['N'][i],
                                                         crd['G'][i],
                                                         crd['O'][i])
        print(line)
        
row_win = "Winner: Row {0}."
column_win = "Winner: Column {0}."
no_win = "Not a winner."


# play_bingo(crd, lon) consumes a bingo card, crd, and a list of integers, lon,
#   and returns a string stating what column or row is winner or not and mutates
#   crd' number which also appear in lon into 'XX'

# play_bingo: Bingocard (listof Int) -> Str

# Effect: the same numbers between crd and lon are mutated into 'XX' 

# Requires:
# integers in lon are between 1 to 75

# Examples:
# EX1
# If bgo_crd = {'O': [61, 72, 'XX', 67, 74], 'I': [25, 23, 'XX', 20, 26],\
#               'N': [43, 38, 'XX', 36, 40], 'B': ['XX', 'XX', 6, 'XX', 10],
#               'G': [56, 53, 'XX', 47, 52]}
# play_bingo(bgo_crd,[6]) => 'Winner: Row 3.'
# EX2
# If my_card = {'O': [65, 62, 'XX', 64, 74], 'I': [22, 25, 'XX', 20, 26],
#               'N': [41, 45, 'XX', 33, 43], 'B': ['XX', 'XX', 14, 'XX', 'XX'],
#               'G': [55, 60, 'XX', 53, 56]}
# play_bingo(my_card, [55,50,22]) => 'Not a winner.'
# EX3 - continue playing
# play_bingo(my_card, [14]) => 'Winner: Column B.'

def play_bingo(crd,lon):
    def replace_xx(lst, num):
        k = 0
        while k < len(lst):
            if lst[k] == num:
                lst[k] = 'XX'
                k += 1
            else:
                k += 1            
        return lst   
    
    def bingo_win(crd_list):
        for z in crd:   
            if crd[z] == ['XX', 'XX', 'XX', 'XX', 'XX']:
                return True    
        for t in range(5):
            if crd['B'][t] == crd['I'][t] == crd['N'][t] == \
               crd['G'][t] == crd['O'][t] == 'XX':
                return True
            
    for rip in lon:
        if bingo_win(crd):
            for z in crd:
                if crd[z] == ['XX', 'XX', 'XX', 'XX', 'XX']:
                    return column_win.format(z)
        
            for t in range(5):
                if crd['B'][t] == crd['I'][t] == crd['N'][t] == \
                   crd['G'][t] == crd['O'][t] == 'XX':
                    return row_win.format(t+1)     
                
        if 1 <= rip <= 15:
            replace_xx(crd['B'], rip)
        elif rip <= 30:
            replace_xx(crd['I'], rip)
        elif rip <= 45:
            replace_xx(crd['N'], rip)
        elif rip <= 60:
            replace_xx(crd['G'], rip)
        else:
            replace_xx(crd['O'], rip)
    
    for z in crd:   
        if crd[z] == ['XX', 'XX', 'XX', 'XX', 'XX']:
            return column_win.format(z)    
    for t in range(5):
        if crd['B'][t] == crd['I'][t] == crd['N'][t] == \
           crd['G'][t] == crd['O'][t] == 'XX':
            return row_win.format(t+1)    
    
    return no_win
    

        
# Test 

bingo_1 ={'B': [15, 10, 4, 13, 3], 'I': [17, 22, 30, 28, 19], \
          'N': [33, 32, 'XX', 44, 43], 'G': [57, 60, 47, 53, 56], \
          'O': [65, 69, 73, 62, 72]}
bingo_2 = {'B': [3, 2, 11, 6, 1], 'I': [26, 23, 16, 27, 17],\
           'N': [35, 42, 'XX', 33, 38], 'G': [55, 58, 50, 54, 51],\
           'O': [72, 75, 71, 61, 64]}
bingo_3 = {'B': [2, 5, 15, 13, 3], 'I': [24, 30, 25, 27, 21],\
           'N': [40, 44, 'XX', 31, 41], 'G': [53, 46, 47, 57, 54],\
           'O': [72, 67, 71, 61, 66]}
bingo_4 = {'B': [10, 14, 1, 5, 8], 'I': [22, 23, 21, 16, 18],\
           'N': [39, 36, 'XX', 45, 40], 'G': [52, 58, 50, 48, 53], \
           'O': [62, 75, 70, 64, 72]}
bingo_5 = {'B': [11, 13, 8, 15, 3], 'I': [23, 27, 25, 16, 24],\
           'N': [43, 32, 'XX', 44, 41], 'G': [46, 58, 50, 55, 54],\
           'O': [73, 62, 74, 69, 65]}
bcard = {'O': [73, 61, 64, 72, 70], 'I': [29, 27, 28, 21, 17],
         'N': [33, 40, 'XX', 42, 43], 'B': [13, 8, 5, 15, 1],
         'G': [49, 55, 60, 56, 54]}

# T1 - no win - no win - win column I
check.expect('T1a', play_bingo(bingo_1, [15,22,60,69]), no_win)
check.expect('T1a(bingo_1)', bingo_1, {'B': ['XX', 10, 4, 13, 3], 'I': [17, 'XX', 30, 28, 19], \
                                      'N': [33, 32, 'XX', 44, 43], 'G': [57, 'XX', 47, 53, 56], \
                                      'O': [65, 'XX', 73, 62, 72]})
check.expect('T1b', play_bingo(bingo_1, [30, 47, 72]), no_win)
check.expect('T1b(bingo_1)', bingo_1, {'B': ['XX', 10, 4, 13, 3], 'I': [17, 'XX', 'XX', 28, 19], \
                                      'N': [33, 32, 'XX', 44, 43], 'G': [57, 'XX', 'XX', 53, 56], \
                                      'O': [65, 'XX', 73, 62, 'XX']})
check.expect('T1c', play_bingo(bingo_1, [17, 28, 19]), 'Winner: Column I.')
check.expect('T1c(bingo_1)', bingo_1, {'B': ['XX', 10, 4, 13, 3], 'I': ['XX', 'XX', 'XX', 'XX', 'XX'], \
                                      'N': [33, 32, 'XX', 44, 43], 'G': [57, 'XX', 'XX', 53, 56], \
                                      'O': [65, 'XX', 73, 62, 'XX']})

# T2 - no win - both column G and Row 5
check.expect('T2a', play_bingo(bingo_2, [55,50,51,1,33,17]), no_win)
check.expect('T2a(bingo_2)', bingo_2, {'B': [3, 2, 11, 6, 'XX'], 'I': [26, 23, 16, 27, 'XX'],\
                                       'N': [35, 42, 'XX', 'XX', 38], 'G': ['XX', 58, 'XX', 54, 'XX'],\
                                       'O': [72, 75, 71, 61, 64]})
check.expect('T2b', play_bingo(bingo_2, [64,58,54,38]), 'Winner: Column G.')
check.expect('T2b(bingo_2)', bingo_2, {'B': [3, 2, 11, 6, 'XX'], 'I': [26, 23, 16, 27, 'XX'],\
                                       'N': [35, 42, 'XX', 'XX', 38], 'G': ['XX', 'XX', 'XX', 'XX', 'XX'],\
                                       'O': [72, 75, 71, 61, 'XX']})

# T3 - no win - no win - no win
check.expect('T3a', play_bingo(bingo_3, [2,15,47,66,25,21,41,44]), no_win)
check.expect('T3a(bingo_3)', bingo_3, {'B': ['XX', 5, 'XX', 13, 3], 'I': [24, 30, 'XX', 27, 'XX'],\
                                       'N': [40, 'XX', 'XX', 31, 'XX'], 'G': [53, 46, 'XX', 57, 54],\
                                       'O': [72, 67, 71, 61, 'XX']})
check.expect('T3b', play_bingo(bingo_3, [3,67,72,57]), no_win)
check.expect('T3b(bingo_3)', bingo_3, {'B': ['XX', 5, 'XX', 13, 'XX'], 'I': [24, 30, 'XX', 27, 'XX'],\
                                       'N': [40, 'XX', 'XX', 31, 'XX'], 'G': [53, 46, 'XX', 'XX', 54],\
                                       'O': ['XX', 'XX', 71, 61, 'XX']})
check.expect('T3c', play_bingo(bingo_3, [24,30,13,31,61]), no_win)
check.expect('T3c(bingo_3)', bingo_3, {'B': ['XX', 5, 'XX', 'XX', 'XX'], 'I': ['XX', 'XX', 'XX', 27, 'XX'],\
                                       'N': [40, 'XX', 'XX', 'XX', 'XX'], 'G': [53, 46, 'XX', 'XX', 54],\
                                       'O': ['XX', 'XX', 71, 'XX', 'XX']})

# T4 - Row 5
check.expect('T4a', play_bingo(bingo_4, [14,36,75,23,58]), "Winner: Row 2.")
check.expect('T4a(bingo_4)', bingo_4, {'B': [10, 'XX', 1, 5, 8], 'I': [22, 'XX', 21, 16, 18],\
                                       'N': [39, 'XX', 'XX', 45, 40], 'G': [52, 'XX', 50, 48, 53], \
                                       'O': [62, 'XX', 70, 64, 72]})

# T5 - Row 1,2,3,4,5, Column B I N G O
check.expect('T5a', play_bingo(bingo_5, [11,13,8,15,3,23,27,25,16,24,43,32,44,41,46,58,50,54,55,73,62,74,69,65]), "Winner: Column B.")
check.expect('T5a(bingo_5)', bingo_5, {'B': ['XX', 'XX', 'XX', 'XX', 'XX'], 'I': [23, 27, 25, 16, 24],\
                                       'N': [43, 32, 'XX', 44, 41], 'G': [46, 58, 50, 55, 54],\
                                       'O': [73, 62, 74, 69, 65]})

# T6 - Example on pdf
check.expect('Ex1', play_bingo(bcard,[29,27,45,15,61,17,60,21,13,28,70,33]), 'Winner: Column I.')
check.expect('Ex1(bcard)', bcard, {'O': [73, 'XX', 64, 72, 70],
                          'I': ['XX', 'XX', 'XX', 'XX', 'XX'], 'N': [33, 40, 'XX', 42, 43],
                          'B': ['XX', 8, 5, 'XX', 1], 'G': [49, 55, 'XX', 56, 54]})


from random import randint

# make_bingo_card() returns a randomized Bingocard
# make_bingo_card: None -> Bingocard
def make_bingo_card():
    interval_width = 15
    card = {}
    for i in range(5):
        L = []
        while len(L) < 5:
            n = randint(interval_width*i+1,interval_width*(i+1))
            if not n in L:
                L.append(n)
                
        if i == 0:
            card['B'] = L
        elif i == 1:
            card['I'] = L
        elif i == 2:
            L[2] = 'XX'
            card['N'] = L
        elif i == 3:
            card['G'] = L
        else:
            card['O'] = L
    
    return card






**** a08q3.py *****************************************************************
##===============================================
##   Jiadong Mai (20557203)
##   CS 116 Winter 2018
##   Assignment 08, Question 3
##===============================================

#q3
import math
import check
class Vector:
    '''Fields: x(Int), y(Int)'''
    def __init__(self,xVal,yVal):
        self.x = xVal
        self.y = yVal
        
    def __eq__(self,other):
        if isinstance(other,Vector):
            return self.x == other.x and self.y == other.y
        else:
            return False
        
    def __repr__(self):
        return "Vector({0},{1})".format(self.x,self.y)
          
    
    
    #q3b
    
    # NOTE: for these functions you still need the full design recipe
    # however the Tests section will have to be done OUTSIDE of the class
    
    # __add__(self, other) consume 2 vectors, self and other, and return a new vector
    # __add__: Vector Vector -> Vector
    # Examples:
    # if u = Vector(2,3) and v = Vector(4,-1)
    # u + v => Vector(6,2)    
    def __add__(self,other):
        return Vector(self.x+other.x, self.y+other.y)    
    
    # __mul__(self, other) consume 2 vectors, self and other, and return an integer 
    # __mul__: Vector Vector -> Int
    # Examples:
    # if u = Vector(2,3) and v = Vector(4,-1)
    # u * v  => 5    
    def __mul__(self,other):
        return self.x*other.x + self.y*other.y
    
    # length(self) consume a single vector, self, and return a Float 
    # length: Vector -> Float
    # Examples:
    # if u = Vector(2,3) and v = Vector(4,-1)
    # u.length() => 3.6055....
    # v.length() => 4.1231....    
    def length(self):
        return math.sqrt(self.x**2 + self.y**2)
    
    # scale(self, k) consume a vector, self, and an integer, k, and mutate the vector 
    # scale: Vector Int -> None
    # Examples:
    # if u = Vector(2,3) and v = Vector(4,-1)
    # u.scale(-2) => None , u.x == -4, u.y == -6
    # v.scale(1) => None , v.x == 4, v.y == -1    
    def scale(self,k):
        self.x *= k
        self.y *= k


# Test(q3b): __add__
check.expect('T1(3b1)', Vector(2,3) + Vector(4,-1), Vector(6,2))
check.expect('T2(3b1)', Vector(0,0) + Vector(0,0), Vector(0,0))
check.expect('T3(3b1)', Vector(1,0) + Vector(1,-1), Vector(2,-1))
check.expect('T4(3b1)', Vector(-3,-3) + Vector(-9,-9), Vector(-12,-12))  
# Test(q3b): __mul__
check.expect('T1(3b2)',  Vector(2,3) * Vector(4,-1), 5)
check.expect('T2(3b2)',  Vector(0,0) * Vector(0,0), 0)
check.expect('T3(3b2)',  Vector(1,0) * Vector(1,-1), 1)
check.expect('T4(3b2)',  Vector(-3,-3) * Vector(-9,-9), 54)
# Test(q3b): self.length()
check.within('T1(3b3)', Vector(2,3).length(), 3.6055, 0.0001)
check.within('T2(3b3)', Vector(4,-1).length(), 4.1231, 0.0001)
check.within('T3(3b3)', Vector(0,0).length(), 0.0, 0.0001)
check.within('T4(3b3)', Vector(1,0).length(), 1.0, 0.0001)
check.within('T5(3b3)', Vector(1,-1).length(), 1.41421, 0.0001)
check.within('T6(3b3)', Vector(-3,-3).length(), 4.24264, 0.0001)
check.within('T7(3b3)', Vector(-3, 5).length(), 5.83095, 0.0001)

# Test(q3b): self.scale(k)
u = Vector(2,3)
check.expect('T1(3b4)', u.scale(-2), None)
check.expect('T1(3b4)(x)', u.x, -4)
check.expect('T1(3b4)(y)', u.y, -6)

a = Vector(-1,3)
check.expect('T2(3b4)', a.scale( -1), None)
check.expect('T2(3b4)(x)', a.x, 1)
check.expect('T2(3b4)(y)', a.y, -3)

b = Vector(0,0)
check.expect('T3(3b4)', b.scale(10), None)
check.expect('T3(3b4)(x)', b.x, 0)
check.expect('T3(3b4)(y)', b.y, 0)

c = Vector(-4,-6)
check.expect('T4(3b4)', c.scale( 3), None)
check.expect('T4(3b4)(x)', c.x, -12)
check.expect('T4(3b4)(y)', c.y, -18)

d = Vector(5,-2)
check.expect('T5(3b4)', d.scale(0), None)
check.expect('T5(3b4)(x)', d.x, 0)
check.expect('T5(3b4)(y)', d.y, 0)

e = Vector(0,6)
check.expect('T6(3b4)', e.scale(-5), None)
check.expect('T6(3b4)(x)', e.x, 0)
check.expect('T6(3b4)(y)', e.y, -30)

f = Vector(-2,0)
check.expect('T7(3b4)', f.scale(-1), None)
check.expect('T7(3b4)(x)', f.x, 2)
check.expect('T7(3b4)(y)', f.y, 0)

#q3a
# add_vectors(v1,v2) consume 2 vectors, v1 and v2, and return a new vector
# add_vectors: Vector Vector -> Vector
# Examples:
# if u = Vector(2,3) and v = Vector(4,-1)
# add_vectors(u,v) => Vector(6,2)
def add_vectors(v1,v2):
    new_vector = Vector(0,0)
    new_vector.x = v1.x + v2.x
    new_vector.y = v1.y + v2.y
    return new_vector
# Test:
check.expect('T1(3a1)', add_vectors(Vector(2,3), Vector(4,-1)), Vector(6,2))
check.expect('T2(3a1)', add_vectors(Vector(0,0), Vector(0,0)), Vector(0,0))
check.expect('T3(3a1)', add_vectors(Vector(1,0), Vector(1,-1)), Vector(2,-1))
check.expect('T4(3a1)', add_vectors(Vector(-3,-3), Vector(-9,-9)), Vector(-12,-12))

# dot_product(v1,v2) consume 2 vectors,v1 and v2, and return an integer 
# dot_product: Vector Vector -> Int
# Examples:
# if u = Vector(2,3) and v = Vector(4,-1)
# dot_product(u,v) => 5
def dot_product(v1,v2):
    result = v1.x*v2.x + v1.y*v2.y
    return result

# Test:
check.expect('T1(3a2)', dot_product(Vector(2,3), Vector(4,-1)), 5)
check.expect('T2(3a2)', dot_product(Vector(0,0), Vector(0,0)), 0)
check.expect('T3(3a2)', dot_product(Vector(1,0), Vector(1,-1)), 1)
check.expect('T4(3a2)', dot_product(Vector(-3,-3), Vector(-9,-9)), 54)

# length(vec) consume a single vector, vec, and return a Float 
# length: Vector -> Float
# Examples:
# if u = Vector(2,3) and v = Vector(4,-1)
# length(u) => 3.6055....
# length(v) => 4.1231....
def length(vec):
    result = math.sqrt(vec.x**2 + vec.y**2)
    return result

# Test:
check.within('T1(3a3)', length(Vector(2,3)), 3.6055, 0.0001)
check.within('T2(3a3)', length(Vector(4,-1)), 4.1231, 0.0001)
check.within('T3(3a3)', length(Vector(0,0)), 0.0, 0.0001)
check.within('T4(3a3)', length(Vector(1,0)), 1.0, 0.0001)
check.within('T5(3a3)', length(Vector(1,-1)), 1.41421, 0.0001)
check.within('T6(3a3)', length(Vector(-3,-3)), 4.24264, 0.0001)
check.within('T7(3a3)', length(Vector(-3, 5)), 5.83095, 0.0001)
    
# scale(vec, k) consume a vector, vec, and an integer, k, and mutate the vector 
# scale: Vector Int -> None
# Examples:
# if u = Vector(2,3) and v = Vector(4,-1)
# scale(u,-2) => None , u.x == -4, u.y == -6
# scale(v,1) => None , v.x == 4, v.y == -1
def scale(vec,k):
    vec.x = vec.x * k
    vec.y = vec.y * k

# Test:
u = Vector(2,3)
check.expect('T1(3a4)', scale(u, -2), None)
check.expect('T1(3a4)(x)', u.x, -4)
check.expect('T1(3a4)(y)', u.y, -6)

a = Vector(-1,3)
check.expect('T2(3a4)', scale(a, -1), None)
check.expect('T2(3a4)(x)', a.x, 1)
check.expect('T2(3a4)(y)', a.y, -3)

b = Vector(0,0)
check.expect('T3(3a4)', scale(b, 10), None)
check.expect('T3(3a4)(x)', b.x, 0)
check.expect('T3(3a4)(y)', b.y, 0)

c = Vector(-4,-6)
check.expect('T4(3a4)', scale(c, 3), None)
check.expect('T4(3a4)(x)', c.x, -12)
check.expect('T4(3a4)(y)', c.y, -18)

d = Vector(5,-2)
check.expect('T5(3a4)', scale(d, 0), None)
check.expect('T5(3a4)(x)', d.x, 0)
check.expect('T5(3a4)(y)', d.y, 0)

e = Vector(0,6)
check.expect('T6(3a4)', scale(e, -5), None)
check.expect('T6(3a4)(x)', e.x, 0)
check.expect('T6(3a4)(y)', e.y, -30)

f = Vector(-2,0)
check.expect('T7(3a4)', scale(f, -1), None)
check.expect('T7(3a4)(x)', f.x, 2)
check.expect('T7(3a4)(y)', f.y, 0)



**** a08q4.py *****************************************************************
##===============================================
##   Jiadong Mai (20557203)
##   CS 116 Winter 2018
##   Assignment 08, Question 4
##===============================================

#q4
import math
import check

acute_cat = 'ACUTE'
obtuse_cat = 'OBTUSE'
right_cat = 'RIGHT'
par_cat = 'PARALLEL'

class Vector:
    '''Fields: x(Int), y(Int)'''
    def __init__(self,xVal,yVal):
        self.x = xVal
        self.y = yVal
        
    def __eq__(self,other):
        if isinstance(other,Vector):
            return self.x == other.x and self.y == other.y
        else:
            return False
        
    def __repr__(self):
        return "Vector({0},{1})".format(self.x,self.y)
    
    def __add__(self,other):
        return Vector(self.x+other.x, self.y+other.y)
    
    def __mul__(self,other):
        return self.x*other.x + self.y*other.y
    
    def length(self):
        return math.sqrt(self.x**2 + self.y**2)
    
    def scale(self,k):
        self.x *= k
        self.y *= k


# classify_angles(lov, vec): consumes a list of non_zero vectors, lov, and
#   a single non-zero vector, vec, and returns a dictionary contain 4 keys, 
#   'ACUTE', 'OBTUSE', 'RIGHT', 'PARALLEL'
# classify_angles: (listof Vector) Vector -> (dictof Str (listof Vector))
# Requires:
# both lov and vec are non-zero vectors
# Examples:
# if vecs = [Vector(-4,0), Vector(0,-7), Vector(10,5), Vector(-1,7),\
#            Vector(-5,-3), Vector(4,-6), Vector(-1,7),Vector(-9,3)]
# classify_angles(vecs ,Vector(3,0)) => {'ACUTE': [Vector(10,5), Vector(4,-6)],
#                                        'OBTUSE': [Vector(-1,7), Vector(-5,-3), Vector(-9,3)],
#                                        'RIGHT': [Vector(0,-7)], 'PARALLEL': [Vector(-4,0)]}
# classify_angles(vecs ,Vector(-2,3)) => {'ACUTE': [Vector(-4,0), Vector(-1,7), Vector(-5,-3), Vector(-9,3)],
#                                         'OBTUSE': [Vector(0,-7), Vector(10,5)], 'RIGHT': [],
#                                         'PARALLEL': [Vector(4,-6)]}

def classify_angles(lov,vec):
    result = {acute_cat: [], obtuse_cat: [], right_cat: [], par_cat: []}
    
    for k in lov:
        cos = (k * vec) / (k.length() * vec.length())
        if (k*vec)**2 == (k.x**2 + k.y**2)*(vec.x**2 + vec.y**2):
            if k in result[par_cat]:
                None
            else:
                result[par_cat].append(k)
        elif -1<cos<0:
            if k in result[obtuse_cat]:
                None
            else:
                result[obtuse_cat].append(k)
        elif cos == 0:
            if k in result[right_cat]:
                None
            else:
                result[right_cat].append(k)
        elif cos <1:
            if k in result[acute_cat]:
                None
            else:
                result[acute_cat].append(k)
    return result
                
# Test: 

a = [Vector(-4,0), Vector(-3,4), Vector(-6,-5)]
b = [Vector(-4,0), Vector(0,-7), Vector(10,5), Vector(-1,7),\
     Vector(-5,-3), Vector(4,-6), Vector(-1,7),Vector(-9,3)]
c = [Vector(1,1), Vector(2,2), Vector(-1,-1)]

# contain one of the keys in lov
check.expect('Acute', classify_angles(a, Vector(-1,1)),\
             {acute_cat: [Vector(-4,0), Vector(-3,4), Vector(-6,-5)], obtuse_cat: [], right_cat: [], par_cat: []})
check.expect('Vector', classify_angles(a, Vector(6,1)),\
             {acute_cat: [], obtuse_cat: [Vector(-4,0), Vector(-3,4), Vector(-6,-5)], right_cat: [], par_cat: []})
check.expect('Parallel', classify_angles(c, Vector(9,9)),\
             {acute_cat: [], obtuse_cat: [], right_cat: [], par_cat: [Vector(1,1), Vector(2,2), Vector(-1,-1)]})
check.expect('Right', classify_angles(c, Vector(-9,9)),\
             {acute_cat: [], obtuse_cat: [], right_cat: [Vector(1,1), Vector(2,2), Vector(-1,-1)], par_cat:[] })
# contain two of the keys in lov
check.expect('Right & Obtuse', classify_angles(a, Vector(4,3)),\
             {acute_cat: [], obtuse_cat: [Vector(-4,0), Vector(-6,-5)], right_cat: [Vector(-3,4)], par_cat: []})
# contain three of the keys in lov
check.expect('Acute, Obtuse and Parallel', classify_angles(b, Vector(-2,3)), \
             {'ACUTE': [Vector(-4,0), Vector(-1,7), Vector(-5,-3), Vector(-9,3)],
             'OBTUSE': [Vector(0,-7), Vector(10,5)], 'RIGHT': [],
             'PARALLEL': [Vector(4,-6)]})             
# contain all in lov
check.expect('All', classify_angles(b, Vector(3,0)), {'ACUTE': [Vector(10,5), Vector(4,-6)],
                                                      'OBTUSE': [Vector(-1,7), Vector(-5,-3), Vector(-9,3)],
                                                      'RIGHT': [Vector(0,-7)], 'PARALLEL': [Vector(-4,0)]})
        
        
   
        
        


**** End of graded assignment. *************************************************
