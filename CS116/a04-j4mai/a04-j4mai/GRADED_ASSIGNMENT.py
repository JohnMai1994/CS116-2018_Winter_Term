ASSIGNMENT 04
Student's Quest ID: j4mai

**** Testing Results **********************************************************

65/69   Total Mark

 ** Question 1: 14/14
 ** Question 2: 16/16
 ** Question 3: 28/32
 ** Question 4: 7/7

(Question 1, Test t01, 1 marks): ^apowers:base^a: Passed; passed.
(Question 1, Test t02, 1 marks): ^apowers:general^a: Passed; passed.
(Question 1, Test t03, 1 marks): ^apowers:edge^a: Passed; passed.
(Question 1, Test t04, 1 marks): ^apowers:zero^a: Passed; passed.
(Question 1, Test t05, 1 marks): ^awins:base^a: Passed; passed.
(Question 1, Test t06, 1 marks): ^awins:general^a: Passed; passed.
(Question 1, Test t07, 1 marks): ^awins:no wins^a: Passed; passed.
(Question 1, Test t08, 1 marks): ^awins:all wins^a: Passed; passed.
(Question 1, Test t09, 1 marks): ^awins:tie^a: Passed; passed.
(Question 1, Test t10, 1 marks): ^awins:one game^a: Passed; passed.
(Question 1, Test t11, 1 marks): ^aadd_lists:base^a: Passed; passed.
(Question 1, Test t12, 1 marks): ^aadd_lists:general^a: Passed; passed.
(Question 1, Test t13, 1 marks): ^aadd_lists:edge^a: Passed; passed.
(Question 1, Test t14, 1 marks): ^aadd_lists:no change^a: Passed; passed.
(Question 2, Test t01, 1 marks): ^ashouting:base^a: Passed; passed.
(Question 2, Test t02, 1 marks): ^ashouting:edge^a: Passed; passed.
(Question 2, Test t03, 1 marks): ^ashouting:ties^a: Passed; passed.
(Question 2, Test t04, 1 marks): ^ashouting:general^a: Passed; passed.
(Question 2, Test t05, 1 marks): ^ashouting:ignore^a: Passed; passed.
(Question 2, Test t06, 1 marks): ^ashouting:all same case^a: Passed; passed.
(Question 2, Test t07, 1 marks): ^areplace:base^a: Passed; passed.
(Question 2, Test t08, 1 marks): ^areplace:general^a: Passed; passed.
(Question 2, Test t09, 1 marks): ^areplace:edge^a: Passed; passed.
(Question 2, Test t10, 1 marks): ^areplace:all^a: Passed; passed.
(Question 2, Test t11, 1 marks): ^areplace:none^a: Passed; passed.
(Question 2, Test t12, 1 marks): ^aquot:base^a: Passed; passed.
(Question 2, Test t13, 1 marks): ^aquot:general^a: Passed; passed.
(Question 2, Test t14, 1 marks): ^aquot:one^a: Passed; passed.
(Question 2, Test t15, 1 marks): ^aquot:none^a: Passed; passed.
(Question 2, Test t16, 1 marks): ^aquot:all^a: Passed; passed.
(Question 3, Test t01, 1 marks): ^acount:base^a: FAILED; FAILED: exception oc-
    curred: IndexError: list index out of range
(Question 3, Test t02, 1 marks): ^acount:3x3:zero^a: Passed; passed.
(Question 3, Test t03, 1 marks): ^acount:3x3:tl^a: Passed; passed.
(Question 3, Test t04, 1 marks): ^acount:3x3:t^a: Passed; passed.
(Question 3, Test t05, 1 marks): ^acount:3x3:tr^a: Passed; passed.
(Question 3, Test t06, 1 marks): ^acount:3x3:l^a: Passed; passed.
(Question 3, Test t07, 1 marks): ^acount:3x3:r^a: Passed; passed.
(Question 3, Test t08, 1 marks): ^acount:3x3:bl^a: Passed; passed.
(Question 3, Test t09, 1 marks): ^acount:3x3:b^a: Passed; passed.
(Question 3, Test t10, 1 marks): ^acount:3x3:br^a: Passed; passed.
(Question 3, Test t11, 1 marks): ^acount:3x3:corners:tl^a: Passed; passed.
(Question 3, Test t12, 1 marks): ^acount:3x3:corners:bl^a: Passed; passed.
(Question 3, Test t13, 1 marks): ^acount:3x3:corners:tr^a: Passed; passed.
(Question 3, Test t14, 1 marks): ^acount:3x3:corners:br^a: Passed; passed.
(Question 3, Test t15, 1 marks): ^acount:3x3:edges:t^a: Passed; passed.
(Question 3, Test t16, 1 marks): ^acount:3x3:edges:l^a: Passed; passed.
(Question 3, Test t17, 1 marks): ^acount:3x3:edges:r^a: Passed; passed.
(Question 3, Test t18, 1 marks): ^acount:3x3:edges:b^a: Passed; passed.
(Question 3, Test t19, 1 marks): ^acount:3x3:ignore_middle^a: Passed; passed.
(Question 3, Test t20, 1 marks): ^acount:4x4:all_numbers:8^a: Passed; passed.
(Question 3, Test t21, 1 marks): ^acount:4x4:all_numbers:7^a: Passed; passed.
(Question 3, Test t22, 1 marks): ^acount:4x4:all_numbers:6^a: Passed; passed.
(Question 3, Test t23, 1 marks): ^acount:4x4:all_numbers:5^a: Passed; passed.
(Question 3, Test t24, 1 marks): ^acount:4x4:all_numbers:4^a: Passed; passed.
(Question 3, Test t25, 1 marks): ^acount:4x4:all_numbers:3^a: Passed; passed.
(Question 3, Test t26, 1 marks): ^acount:4x4:all_numbers:2^a: Passed; passed.
(Question 3, Test t27, 1 marks): ^acount:narrow:two_edge:hori^a: FAILED; FAILE\
D:
    exception occurred: IndexError: list index out of range
(Question 3, Test t28, 1 marks): ^acount:narrow:two_edge:vert^a: Passed; passe\
d.
(Question 3, Test t29, 1 marks): ^acount:narrow:corners:hori:left^a: FAILED;
    FAILED: exception occurred: IndexError: list index out of range
(Question 3, Test t30, 1 marks): ^acount:narrow:corners:hori:right^a: FAILED;
    FAILED: exception occurred: IndexError: list index out of range
(Question 3, Test t31, 1 marks): ^acount:narrow:corners:vert:left^a: Passed;
    passed.
(Question 3, Test t32, 1 marks): ^acount:narrow:corners:vert:right^a: Passed;
    passed.
(Question 4, Test t01, 1 marks): ^agame_won:1x1^a: Passed; passed.
(Question 4, Test t02, 1 marks): ^agame_won:3x3^a: Passed; passed.
(Question 4, Test t03, 1 marks): ^agame_won:3x3alt^a: Passed; passed.
(Question 4, Test t04, 1 marks): ^agame_won:2x2empty^a: Passed; passed.
(Question 4, Test t05, 1 marks): ^agame_won:2x2full^a: Passed; passed.
(Question 4, Test t06, 1 marks): ^agame_won:narrow:horiz^a: Passed; passed.
(Question 4, Test t07, 1 marks): ^agame_won:narrow:vert^a: Passed; passed.
138 control characters removed.


**** testing_result.txt *****************************************************************
Total number of tests missing: 17

powers: 1 of the 3 required cases were missing:
 - Part A n or k is 1

count_wins: 1 of the 5 required cases were missing:
 - Part B length 1 lists

add_lists: 2 of the 3 required cases were missing:
 - Part C empty lists
 - Part C length 1 lists

shouting: 1 of the 6 required cases were missing:
 - Part A empty string

replace: 2 of the 5 required cases were missing:
 - Part B empty string
 - Part B length 1 list

keep_quotients: 2 of the 4 required cases were missing:
 - Part C empty lists
 - Part C dividing by 1

count_mines: 6 of the 12 required cases were missing:
 - return vale is 4
 - return vale is 5
 - return vale is 6
 - return vale is 7
 - return vale is 8
 - width and/or height of grid is 1

game_won: 2 of the 5 required cases were missing:
 - Grid is all mines or all safe
 - width and/or height of grid is 1



**** a04q1.py *****************************************************************
##===============================================
##   Jiadong Mai (20557203)
##   CS 116 Winter 2018
##   Assignment 04, Question 1
##===============================================

import math
import check

## Question 1
# Question1(a)
# powers_plus(n,k,a) returns a list containning the first k powers of n, 
#    starting with the ath power.
# powers_plus: Nat Nat Nat -> (Listof Nat)
# Examples:
# powers_plus(2,3,0) => [1,2,4]
def powers_plus(n,k,a):
    if a == k:
        return []
    else:
        return [n**a] + powers_plus(n,k,a+1)
# powers(n,k) returns a list containning the first k powers of n, starting with
#   the 0th power.
# powers: Nat Nat -> (Listof Nat)
# Examples:
# powers(2,4) => [1,2,4,8]
def powers(n,k):
    return powers_plus(n,k,0)
# Test1: n = 0
check.expect('Q1aT1', powers(0, 3), [1,0,0])
check.expect('Q1aT2', powers(0, 0), [])
# Test2: k = 0
check.expect('Q1aT3', powers(3, 0), [])
# Test3: k != 0 and n != 0
check.expect('Q1aT4', powers(3,4), [1,3,9,27])


# Question1(b)
# count_wins(lst1,lst2) returns the number of times that an element in the lst1
#     is greater than the corresponding element in the lst2
# count_wins: (listof Nat) (listof Nat) -> Nat
# Examples:
# count_wins([1,2,0,4],[4,1,0,2]) => 2
def count_wins(lst1,lst2):
    if lst1[0:] == [] and lst2[0:] == []:
        return 0
    elif  lst1[0] > lst2[0]:
        return 1 + count_wins(lst1[1:], lst2[1:])
    else: 
        return 0 + count_wins(lst1[1:], lst2[1:])
# Test1: lst1 and lst2 equal to []
check.expect('Q1bT1', count_wins([],[]), 0)
# Test2: all lst1 elements greater than lst2
check.expect('Q1bT2', count_wins([5,6,7,8,9], [1,2,3,4,5]), 5)
# Test3: all lst2 elements greater than lst1
check.expect('Q1bT3', count_wins([1,2,3,4,5], [5,6,7,8,9]), 0)
# Test4: Regular Example
check.expect('Q1bT4', count_wins([5,2,8,4,5], [2,6,7,10,-1]), 3)

# Question1(c)
# add_lists_position(lst1, lst2, k) mutates lst1, values in lst1 from k position
#  plus the corresponding values in the lst2. the function return None
# add_lists_position: (listof Int) (listof Int) Nat -> None
# Examples:
# a = [1,5,7], b = [3,4,6]
# add_lists([a],[b],1) => None
# After calling add_lists([a],[b]), a become [1,9,13]
def add_lists_position(lst1,lst2,k):
    if k < len(lst1) or k < len(lst2):
        lst1[k] = lst1[k] + lst2[k]
        add_lists_position(lst1,lst2,k+1)
        
# add_lists(lst1, lst2) mutates lst1, each values in lst1 plus the corresponding
#   values in the lst2. the function return None
# add_lists: (listof Int) (listof Int) -> None
# Examples:
# a = [1,5,7], b = [3,4,6]
# add_lists([a],[b]) => None
# After calling add_lists([a],[b]), a become [4,9,13]
def add_lists(lst1,lst2):
    add_lists_position(lst1,lst2,0)
    
# Test1: Regular Test
a = [1,5,7]
b = [3,4,6]
check.expect('Q1cT1',add_lists(a,b), None)
check.expect('Q1cT1(a)',a, [4,9,13])
# Test2: 
c = [-4,-2]
d = [-1,-3]
check.expect('Q1cT2',add_lists(c,d), None)
check.expect('Q1cT2(a)',c, [-5,-5])

**** a04q2.py *****************************************************************
##===============================================
##   Jiadong Mai (20557203)
##   CS 116 Winter 2018
##   Assignment 04, Question 2
##===============================================

import math
import check

## Question 2
# Question2(a)
# shouting(s) return True if the s contains more Capital Letters than it does
#    lower case letters, else, return False
# shouting: Str -> Bool
# Examples:
# shouting("HELLO World!") => True
def shouting(s):
    if len(list(filter(lambda high: high[:1].isupper(), s))) > \
       len(list(filter(lambda low: low[:1].islower(), s))):
        return True
    else:
        return False
# Test1: string is contain all same type letters
check.expect('Q2aT1', shouting("abcdefg"), False)
check.expect('Q2aT2', shouting("ASFKSD"), True)
check.expect('Q2aT3', shouting("123!@#"), False)
# Test2: Regular example
check.expect('Q2aT4', shouting("AFKLla"), True) 
check.expect('Q2aT5', shouting("AFKLl123a"), True)
check.expect('Q2aT6', shouting("ALl3a"), False)
check.expect('Q2aT7', shouting("AFKL1235"), True)

# Question2(b)
# replace_fun(k, match, rep) return a number, if k is equal to match, then return
#   rep, else return itself
# replace_fun: Int Int Int -> Int
# Examples:
# replace_fun(5, 5, 3) => 3
# replace_fun(5, 6, 3) => 5

def replace_fun(k, match, rep):
    if k == match:
        return rep
    else:
        return k
# replace(lst, match, rep) return a list with same number as lst, but all 
#   occurrences of match will be replaced by rep
# replace: (listof Int) Int Int -> (listof Int)
# Examples:
# replace([1,2,-1,2], 2, 0) => [1,0,-1,0]
def replace(lst,match,rep):
    return list(map(lambda k: replace_fun(k, match, rep), lst))
# Test1: Regular Example
check.expect("Q2bT1", replace([1,2,-1,2], 2, 0), [1,0,-1,0])
check.expect("Q2bT2", replace([1,2,-1,2,4,2], 2, 5), [1,5,-1,5,4,5])
check.expect("Q2bT3", replace([2,2,2,2], 2, 0), [0,0,0,0])
check.expect("Q2bT4", replace([1,3,-1,5], 2, 0), [1,3,-1,5])

# Question2(c)
# keep_quotients(lst,n) return a list that contains the quotients the corresponding
#   elements of lst by n
# keep_quotients: (listof Nat) Nat -> (listof Nat)
# Examples:
# keep_quotients([6,8,7,2], 2) => [3,4,1]
def keep_quotients(lst,n):
    return list(map(lambda l: int(l/n),list(filter(lambda div_2: div_2%n == 0, lst))))
# Test
check.expect('Q2cT1', keep_quotients([6,8,7,2], 2), [3,4,1])
check.expect('Q2cT1', keep_quotients([6,8,9,2,3], 7), [])
check.expect('Q2cT1', keep_quotients([6,8,10,2], 2), [3,4,5,1])
check.expect('Q2cT1', keep_quotients([4,3,7,9,6], 3), [1,3,2])

**** a04q3.py *****************************************************************
##===============================================
##   Jiadong Mai (20557203)
##   CS 116 Winter 2018
##   Assignment 04, Question 3
##===============================================

import math
import check


# A MineGrid is a (listof (listof Bool))
# Requires:  All lists are non-empty
#            Each (listof Bool) has the same length 

# note: True means mine, False means safe

# A MineBoard is a (listof (listof Str))
# Requires: Each string is either a mine ('*') hidden(' ')
#             or safe (a digit between '0' and '8')
#           All lists are non-empty
#           Each (listof Str) has the same length



# Example board from the assignment file

grid3x3 = [[True ,False,False],
           [False,False,False],
           [False,False,True]]

board3x3 = [[' ', '1', '0'],
            [' ', '2', '1'],
            [' ', ' ', '*']]

grid4x4 = [[True,False,False,False,],
           [False,False,False,False],
           [False,False,True,True],
           [True,False,True,False]]

board4x4 = [['','','',''],
            ['','','',''],
            ['','','',''],
            ['','','','']]


## Question 3

# count_mines_no(grid,row,col) returns how many mine tiles are near to the tile at
#   the position row and col in the grid, includes diagonals and itself
# count_mines_no: MineBoard Nat Nat -> None
# requires: grid and board have the same dimensions and are consistent
#           0 <= row < height of board
#           0 <= col < width  of board
# examples:
# count_mines_no(grid4x4,0,0) => 1
# count_mines_no(grid4x4,3,2) => 3
def count_mines_no(grid,row,col):
    row_line = len(grid)-1
    col_line = len(grid[1])
    if row-1 < 0:
        return len(list(filter(lambda s: s== True,grid[row][max(0,col-1):min(col_line,col+2)])))\
               + len(list(filter(lambda s: s== True,grid[min(row_line,row+1)][max(0,col-1):min(col_line,col+2)]))) 
    elif row + 1 > row_line:
        return len(list(filter(lambda s: s== True,grid[max(0,row-1)][max(0,col-1):min(col_line,col+2)])))\
               + len(list(filter(lambda s: s== True,grid[row][max(0,col-1):min(col_line,col+2)])))
    else:    
        return len(list(filter(lambda s: s== True,grid[max(0,row-1)][max(0,col-1):min(col_line,col+2)])))\
               + len(list(filter(lambda s: s== True,grid[row][max(0,col-1):min(col_line,col+2)])))\
               + len(list(filter(lambda s: s== True,grid[min(row_line,row+1)][max(0,col-1):min(col_line,col+2)])))    

# count_mines(grid,row,col) returns how many mine tiles are near to the tile at
#   the position row and col in the grid, includes diagonals
# count_mines: MineBoard Nat Nat -> None
# requires: grid and board have the same dimensions and are consistent
#           0 <= row < height of board
#           0 <= col < width  of board
# examples:
# count_mines(grid4x4,0,1) => 1
# count_mines(grid4x4,3,3) => 3
# count_mines(grid4x4,3,0) => 0
def count_mines(grid,row,col):
    if grid[row][col]:
        return 0
    else:
        return count_mines_no(grid,row,col)
# Test1 for helper function: No Mine surrounded
check.expect('Q3T1H', count_mines(grid3x3,2,0), 0)
check.expect('Q3T2H', count_mines(grid4x4,0,3), 0)
# Test2 for helper funciton: one Mine surrounded
check.expect('Q3T3H', count_mines(grid3x3,1,0), 1)
check.expect('Q3T4H', count_mines(grid4x4,1,0), 1)
check.expect('Q3T5H', count_mines(grid4x4,2,0), 1)
# Test3 for helper function: two or more Mine surrounded
check.expect('Q3T6H', count_mines(grid3x3,1,1), 2)
check.expect('Q3T7H', count_mines(grid4x4,3,1), 3)
check.expect('Q3T8H', count_mines(grid4x4,3,3), 3)
# Test4 for helper function: on Mine
check.expect('Q3T9H', count_mines(grid4x4,0,0), 0)
check.expect('Q3T10H', count_mines(grid4x4, 2,2),0)

# reveal(grid,board, row, col) reveals the tile at the given row and col(umn)
#   in board, using the mine positions from grid
# reveal: MineGrid MineBoard -> None
# requires: grid and board have the same dimensions and are consistent
#           0 <= row < height of board
#           0 <= col < width  of board
# effects: board is mutated
# Examples:
# reveal(grid3x3, board3x3, 0,0) => None, and changes contents of board3x3
# to [['*', '1', '0'], [' ', '2', '1'], [' ', ' ', '*']]
# reveal(grid3x3, board3x3, 1,0) => None, and changes contents of board3x3
# to [[' ', '1', '0'], ['1', '2', '1'], [' ', ' ', '*']]
def reveal(grid,board,row,col):
    if grid[row][col]:
        board[row][col] = '*'
    else:
        board[row][col] = str(count_mines(grid,row,col))
# Tests:
grid3x3 = [[True ,False,False],
           [False,False,False],
           [False,False,True]]

board3x3 = [[' ', '1', '0'],
            [' ', '2', '1'],
            [' ', ' ', '*']]    

# Test1: the position is mine
check.expect('Q3T1', reveal(grid3x3,board3x3,0,0), None)
check.expect('Q3T1(M)', board3x3, [['*', '1', '0'], [' ', '2', '1'],[' ', ' ', '*']])

# Test2: the position is surrounded by 1 mine
check.expect('Q3T2', reveal(grid3x3,board3x3,1,0), None)
check.expect('Q3T2(1)', board3x3, [['*', '1', '0'], ['1', '2', '1'],[' ', ' ', '*']])
check.expect('Q3T3', reveal(grid3x3,board3x3,2,1), None)
check.expect('Q3T3(1)', board3x3, [['*', '1', '0'], ['1', '2', '1'],[' ', '1', '*']])
# Test3: the position is not surrounded by mine
check.expect('Q3T4', reveal(grid3x3,board3x3,2,0), None)
check.expect('Q3T4(None)', board3x3, [['*', '1', '0'], ['1', '2', '1'],['0', '1', '*']])







**** a04q4.py *****************************************************************
##===============================================
##   Jiadong Mai (20557203)
##   CS 116 Winter 2018
##   Assignment 04, Question 4
##===============================================

import math
import check

# Data definition for Q3 + Q4

# A MineGrid is a (listof (listof Bool))
# Requires:  All lists are non-empty
#            Each (listof Bool) has the same length 

# note: True means mine, False means safe

# A MineBoard is a (listof (listof Str))
# Requires: Each string is either a mine ('*') hidden(' ')
#             or safe (a digit between '0' and '8')
#           All lists are non-empty
#           Each (listof Str) has the same length

# Example board from the assignment file

grid3x3 = [[True ,False,False],
           [False,False,False],
           [False,False,True]]

board3x3 = [[' ', '1', '0'],
            [' ', '2', '1'],
            [' ', ' ', '*']]

board3x3_win = [[' ', '1', '0'],
                ['1', '2', '1'],
                ['0', '1', ' ']]

## Question 4

# game_lost(board) returns true if board contains one or more revealed mines,
#   false otherwise
# game_lost: GameBoard -> Bool

def game_lost(board):
    mined_rows = len(list(filter(lambda row: '*' in row, board)))
    return mined_rows != 0

# line_be_grid_position(lst,b) mutates lst such that each elements in lst is
#   replaced by True or False start from b position
# Effect: lst is mutated
# line_be_grid_position: (listof Str) Nat -> None
# Requires:
# 0 <= b < length of lst
# Example:
# if k = [' ', '1', '0'], then line_be_grid_position(k, 0) is called, k is 
#   now [True, False, False]
def line_be_grid_position(lst,b):   
    if b < len(lst):
        if lst[b] == ' ':
            lst[b] = True
            line_be_grid_position(lst, b+1)
        else:
            lst[b] = False
            line_be_grid_position(lst, b+1)
            
# line_be_grid(lst) return a list of True or False by replacing the element 
#   in lst 
# line_be_grid: (listof Str) -> (listof Bool)
# Example:
# if k = [' ', ' ', '0'], then line_be_grid(k) => [True, True, False]
# if k = ['2', '1', '0'], then line_be_grid(k) => [False, False, False]
def line_be_grid(lst):
    line_be_grid_position(lst, 0)
    return lst

# game_won(grid, board) return True if the game has been won (all safe tiles
#   are revealed and no mine tile), else False
# game_won: MineGrid Gameboard -> Bool
# Examples:
# game_won(grid3x3, board3x3) => False
# game_won(grid3x3, board3x3_win) => False
def game_won(grid,board):
    k = list(map(line_be_grid, board))
    if k == grid:
        return True
    else:
        return False
    
# Tests:
# Test1: Not reveal all the safe or even reveal a mine
board3x3_not_all_safe = [[' ', '1', '0'],
                         [' ', '2', '1'],
                         ['0', '1', ' ']]    
check.expect('Q4T1', game_won(grid3x3, board3x3), False)
check.expect('Q4T2', game_won(grid3x3, board3x3_not_all_safe), False)
# Test2: reveal all the safe and some mine
board3x3_mine = [['*', '1', '0'],
                 ['1', '2', '1'],
                 ['0', '1', ' ']]
check.expect('Q4T3', game_won(grid3x3, board3x3_mine), False)
# Test3: reveal all the safe and no mine
check.expect('Q4T4', game_won(grid3x3, board3x3_win), True)

**** End of graded assignment. *************************************************
